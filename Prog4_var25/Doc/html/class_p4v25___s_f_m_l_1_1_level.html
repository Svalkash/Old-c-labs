<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Prog4_var25: P4v25_SFML::Level Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Prog4_var25
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p4v25___s_f_m_l.html">P4v25_SFML</a></li><li class="navelem"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_p4v25___s_f_m_l_1_1_level-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">P4v25_SFML::Level Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main game class.  
 <a href="class_p4v25___s_f_m_l_1_1_level.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_level_8h_source.html">Level.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9989021a9567747ccec7cb8dc5e51002"><td class="memItemLeft" align="right" valign="top"><a id="a9989021a9567747ccec7cb8dc5e51002"></a>
typedef std::set&lt; <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> * &gt;::<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a></td></tr>
<tr class="memdesc:a9989021a9567747ccec7cb8dc5e51002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for Enemies list. <br /></td></tr>
<tr class="separator:a9989021a9567747ccec7cb8dc5e51002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58380f54548017ddd240fd419b1baf5d"><td class="memItemLeft" align="right" valign="top"><a id="a58380f54548017ddd240fd419b1baf5d"></a>
typedef std::set&lt; <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> * &gt;::<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a58380f54548017ddd240fd419b1baf5d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a58380f54548017ddd240fd419b1baf5d">const_iterator</a></td></tr>
<tr class="memdesc:a58380f54548017ddd240fd419b1baf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for Enemies list. <br /></td></tr>
<tr class="separator:a58380f54548017ddd240fd419b1baf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86cf3beee1987babb82fbf81e9b2cc0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a86cf3beee1987babb82fbf81e9b2cc0c">Level</a> (const std::string &amp;fmap, const std::string &amp;fconfig, const std::string &amp;fsave)</td></tr>
<tr class="memdesc:a86cf3beee1987babb82fbf81e9b2cc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> constructor.  <a href="#a86cf3beee1987babb82fbf81e9b2cc0c">More...</a><br /></td></tr>
<tr class="separator:a86cf3beee1987babb82fbf81e9b2cc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8843aa45b629d9cf39f06df4f2ced8d6"><td class="memItemLeft" align="right" valign="top"><a id="a8843aa45b629d9cf39f06df4f2ced8d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a8843aa45b629d9cf39f06df4f2ced8d6">~Level</a> ()</td></tr>
<tr class="memdesc:a8843aa45b629d9cf39f06df4f2ced8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor; clears Map, Enemies and tileset. <br /></td></tr>
<tr class="separator:a8843aa45b629d9cf39f06df4f2ced8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc6d0b969c911b4bdaa05f046f0178"><td class="memItemLeft" align="right" valign="top"><a id="ad2cc6d0b969c911b4bdaa05f046f0178"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ad2cc6d0b969c911b4bdaa05f046f0178">Level</a> (const <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;)</td></tr>
<tr class="memdesc:ad2cc6d0b969c911b4bdaa05f046f0178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ad2cc6d0b969c911b4bdaa05f046f0178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e585710ac23d051099ff842cad2d1b0"><td class="memItemLeft" align="right" valign="top"><a id="a3e585710ac23d051099ff842cad2d1b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a3e585710ac23d051099ff842cad2d1b0">Level</a> (<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a3e585710ac23d051099ff842cad2d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3e585710ac23d051099ff842cad2d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec44e1cc0e6267d97a1044980886d93c"><td class="memItemLeft" align="right" valign="top"><a id="aec44e1cc0e6267d97a1044980886d93c"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aec44e1cc0e6267d97a1044980886d93c">operator=</a> (const <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;)</td></tr>
<tr class="memdesc:aec44e1cc0e6267d97a1044980886d93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator =. <br /></td></tr>
<tr class="separator:aec44e1cc0e6267d97a1044980886d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3122715e31d3c149c6e1550570350ec"><td class="memItemLeft" align="right" valign="top"><a id="ad3122715e31d3c149c6e1550570350ec"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ad3122715e31d3c149c6e1550570350ec">operator=</a> (<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html">Level</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ad3122715e31d3c149c6e1550570350ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move operator =. <br /></td></tr>
<tr class="separator:ad3122715e31d3c149c6e1550570350ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5520253f0452c7e09b2bebeda1a209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aeb5520253f0452c7e09b2bebeda1a209">save</a> (const std::string &amp;fsave)</td></tr>
<tr class="memdesc:aeb5520253f0452c7e09b2bebeda1a209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves level.  <a href="#aeb5520253f0452c7e09b2bebeda1a209">More...</a><br /></td></tr>
<tr class="separator:aeb5520253f0452c7e09b2bebeda1a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f0994224b847c3a9d3eb278abbb0aa"><td class="memItemLeft" align="right" valign="top"><a id="a99f0994224b847c3a9d3eb278abbb0aa"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a99f0994224b847c3a9d3eb278abbb0aa">getTimeQ</a> () const</td></tr>
<tr class="memdesc:a99f0994224b847c3a9d3eb278abbb0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns time quant. <br /></td></tr>
<tr class="separator:a99f0994224b847c3a9d3eb278abbb0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb994bef73c7dead6fd1d92c652b47a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#abb994bef73c7dead6fd1d92c652b47a2">calcTimeQ</a> (const double &amp;maxTQ=0)</td></tr>
<tr class="memdesc:abb994bef73c7dead6fd1d92c652b47a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates time quant for this level, saves and returns it.  <a href="#abb994bef73c7dead6fd1d92c652b47a2">More...</a><br /></td></tr>
<tr class="separator:abb994bef73c7dead6fd1d92c652b47a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d90637e4e9f416c9027b5adb29dc546"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a3d90637e4e9f416c9027b5adb29dc546">turn</a> (const double &amp;maxTQ=0)</td></tr>
<tr class="memdesc:a3d90637e4e9f416c9027b5adb29dc546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main turn function.  <a href="#a3d90637e4e9f416c9027b5adb29dc546">More...</a><br /></td></tr>
<tr class="separator:a3d90637e4e9f416c9027b5adb29dc546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2242763319c5896c78766f90ca7ad8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a5f2242763319c5896c78766f90ca7ad8">turnUntil</a> (const double &amp;extTQ)</td></tr>
<tr class="memdesc:a5f2242763319c5896c78766f90ca7ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes several turns until external time quant.  <a href="#a5f2242763319c5896c78766f90ca7ad8">More...</a><br /></td></tr>
<tr class="separator:a5f2242763319c5896c78766f90ca7ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cde934cd1b5500fc936fe7efce6b6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a53cde934cd1b5500fc936fe7efce6b6d">pathfind</a> ()</td></tr>
<tr class="memdesc:a53cde934cd1b5500fc936fe7efce6b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pathfind algorithm.  <a href="#a53cde934cd1b5500fc936fe7efce6b6d">More...</a><br /></td></tr>
<tr class="separator:a53cde934cd1b5500fc936fe7efce6b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2030a6c62aa5eb91bec3057de7fdd607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a2030a6c62aa5eb91bec3057de7fdd607">pf_visit</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;curP, const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;prevP)</td></tr>
<tr class="memdesc:a2030a6c62aa5eb91bec3057de7fdd607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pathfind visit function.  <a href="#a2030a6c62aa5eb91bec3057de7fdd607">More...</a><br /></td></tr>
<tr class="separator:a2030a6c62aa5eb91bec3057de7fdd607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a1ce01a1473a5545e186da9e3d425"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a159a1ce01a1473a5545e186da9e3d425">build</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;p, const int &amp;type, const std::string &amp;name)</td></tr>
<tr class="memdesc:a159a1ce01a1473a5545e186da9e3d425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds something at the position.  <a href="#a159a1ce01a1473a5545e186da9e3d425">More...</a><br /></td></tr>
<tr class="separator:a159a1ce01a1473a5545e186da9e3d425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e2923c6d401195bc6c50cb730f86b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a69e2923c6d401195bc6c50cb730f86b4">upgrade</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;p)</td></tr>
<tr class="memdesc:a69e2923c6d401195bc6c50cb730f86b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrades the building at the position.  <a href="#a69e2923c6d401195bc6c50cb730f86b4">More...</a><br /></td></tr>
<tr class="separator:a69e2923c6d401195bc6c50cb730f86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae368bfb4ca44e317f41b66c3df2824a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ae368bfb4ca44e317f41b66c3df2824a7">repair</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;p, const double &amp;healHP=0)</td></tr>
<tr class="memdesc:ae368bfb4ca44e317f41b66c3df2824a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repairs selected wall.  <a href="#ae368bfb4ca44e317f41b66c3df2824a7">More...</a><br /></td></tr>
<tr class="separator:ae368bfb4ca44e317f41b66c3df2824a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c76fa6c6acfc97caa1e19cdbaf656d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_t_stats.html">TStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ae6c76fa6c6acfc97caa1e19cdbaf656d">getTS</a> (const int &amp;lvl) const</td></tr>
<tr class="memdesc:ae6c76fa6c6acfc97caa1e19cdbaf656d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Tower stats for the selected level (from 0).  <a href="#ae6c76fa6c6acfc97caa1e19cdbaf656d">More...</a><br /></td></tr>
<tr class="separator:ae6c76fa6c6acfc97caa1e19cdbaf656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cb5464849681d105baf99ff39e97e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_c_stats.html">CStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a2a0cb5464849681d105baf99ff39e97e">getCS</a> (const int &amp;lvl) const</td></tr>
<tr class="memdesc:a2a0cb5464849681d105baf99ff39e97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Castle stats for the selected level (from 0).  <a href="#a2a0cb5464849681d105baf99ff39e97e">More...</a><br /></td></tr>
<tr class="separator:a2a0cb5464849681d105baf99ff39e97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd95fdd664068d2e8d54e9c46568f7"><td class="memItemLeft" align="right" valign="top"><a id="a0ebd95fdd664068d2e8d54e9c46568f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a0ebd95fdd664068d2e8d54e9c46568f7">getTileWidth</a> () const</td></tr>
<tr class="memdesc:a0ebd95fdd664068d2e8d54e9c46568f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tile width (in pixels). <br /></td></tr>
<tr class="separator:a0ebd95fdd664068d2e8d54e9c46568f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6523d4e53f3f7fb19983ef7202dd838a"><td class="memItemLeft" align="right" valign="top"><a id="a6523d4e53f3f7fb19983ef7202dd838a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a6523d4e53f3f7fb19983ef7202dd838a">size</a> ()</td></tr>
<tr class="memdesc:a6523d4e53f3f7fb19983ef7202dd838a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the enemies on the level. <br /></td></tr>
<tr class="separator:a6523d4e53f3f7fb19983ef7202dd838a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c2d4a753ba752c108e965ce4a5cd8f"><td class="memItemLeft" align="right" valign="top"><a id="af1c2d4a753ba752c108e965ce4a5cd8f"></a>
<a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#af1c2d4a753ba752c108e965ce4a5cd8f">operator[]</a> (const int &amp;x)</td></tr>
<tr class="memdesc:af1c2d4a753ba752c108e965ce4a5cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns link to (x) tile column. UNSAFE: Doesn't check if the tile exists. <br /></td></tr>
<tr class="separator:af1c2d4a753ba752c108e965ce4a5cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a32ce9284ec35334dcf20b946f1f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a0e9a32ce9284ec35334dcf20b946f1f2">operator[]</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;p)</td></tr>
<tr class="memdesc:a0e9a32ce9284ec35334dcf20b946f1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns link to (x, y) tile. SAFE: Checks if the tile exists.  <a href="#a0e9a32ce9284ec35334dcf20b946f1f2">More...</a><br /></td></tr>
<tr class="separator:a0e9a32ce9284ec35334dcf20b946f1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b4f57e00b7162478edb6043aed16e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#abd7b4f57e00b7162478edb6043aed16e">addEnemy</a> (<a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> *ne)</td></tr>
<tr class="memdesc:abd7b4f57e00b7162478edb6043aed16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds enemy to the level.  <a href="#abd7b4f57e00b7162478edb6043aed16e">More...</a><br /></td></tr>
<tr class="separator:abd7b4f57e00b7162478edb6043aed16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa680e34423eaf3c70181447ea21646b1"><td class="memItemLeft" align="right" valign="top"><a id="aa680e34423eaf3c70181447ea21646b1"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aa680e34423eaf3c70181447ea21646b1">begin</a> ()</td></tr>
<tr class="memdesc:aa680e34423eaf3c70181447ea21646b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aa680e34423eaf3c70181447ea21646b1" title="Iterator begin() function for Enemies list. ">begin()</a> function for Enemies list. <br /></td></tr>
<tr class="separator:aa680e34423eaf3c70181447ea21646b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c449f43674df993086ac5c1f8eafdcf"><td class="memItemLeft" align="right" valign="top"><a id="a6c449f43674df993086ac5c1f8eafdcf"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a6c449f43674df993086ac5c1f8eafdcf">end</a> ()</td></tr>
<tr class="memdesc:a6c449f43674df993086ac5c1f8eafdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a6c449f43674df993086ac5c1f8eafdcf" title="Iterator end() function for Enemies list. ">end()</a> function for Enemies list. <br /></td></tr>
<tr class="separator:a6c449f43674df993086ac5c1f8eafdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2780f4caa07c3c15cd0e5339edbb3b2a"><td class="memItemLeft" align="right" valign="top"><a id="a2780f4caa07c3c15cd0e5339edbb3b2a"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a58380f54548017ddd240fd419b1baf5d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a2780f4caa07c3c15cd0e5339edbb3b2a">begin</a> () const</td></tr>
<tr class="memdesc:a2780f4caa07c3c15cd0e5339edbb3b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aa680e34423eaf3c70181447ea21646b1" title="Iterator begin() function for Enemies list. ">begin()</a> function for Enemies list. <br /></td></tr>
<tr class="separator:a2780f4caa07c3c15cd0e5339edbb3b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f06b274320f14a68bbafa20e5f6e6db"><td class="memItemLeft" align="right" valign="top"><a id="a0f06b274320f14a68bbafa20e5f6e6db"></a>
<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a58380f54548017ddd240fd419b1baf5d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a0f06b274320f14a68bbafa20e5f6e6db">end</a> () const</td></tr>
<tr class="memdesc:a0f06b274320f14a68bbafa20e5f6e6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator <a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a6c449f43674df993086ac5c1f8eafdcf" title="Iterator end() function for Enemies list. ">end()</a> function for Enemies list. <br /></td></tr>
<tr class="separator:a0f06b274320f14a68bbafa20e5f6e6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431eee96536e68270fe1ce7d06d05570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a431eee96536e68270fe1ce7d06d05570">destroyBuilding</a> (<a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> &amp;t)</td></tr>
<tr class="memdesc:a431eee96536e68270fe1ce7d06d05570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys building at the tile.  <a href="#a431eee96536e68270fe1ce7d06d05570">More...</a><br /></td></tr>
<tr class="separator:a431eee96536e68270fe1ce7d06d05570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239ef78814c80da434250a4b69c31502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a239ef78814c80da434250a4b69c31502">killEnemy</a> (<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a> it)</td></tr>
<tr class="memdesc:a239ef78814c80da434250a4b69c31502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kills the enemy pointed by the iterator.  <a href="#a239ef78814c80da434250a4b69c31502">More...</a><br /></td></tr>
<tr class="separator:a239ef78814c80da434250a4b69c31502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2917dd109c1cab686d8abe811683a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#acc2917dd109c1cab686d8abe811683a5">removeEnemy</a> (<a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">iterator</a> it)</td></tr>
<tr class="memdesc:acc2917dd109c1cab686d8abe811683a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the enemy pointed by the iterator from the list.  <a href="#acc2917dd109c1cab686d8abe811683a5">More...</a><br /></td></tr>
<tr class="separator:acc2917dd109c1cab686d8abe811683a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f189f8b41a9ae0440b77a42e489d279"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a8f189f8b41a9ae0440b77a42e489d279">checkPos</a> (const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;p)</td></tr>
<tr class="memdesc:a8f189f8b41a9ae0440b77a42e489d279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given position is within the level.  <a href="#a8f189f8b41a9ae0440b77a42e489d279">More...</a><br /></td></tr>
<tr class="separator:a8f189f8b41a9ae0440b77a42e489d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fad3d976a75359b9765e9f0fd6446c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ab1fad3d976a75359b9765e9f0fd6446c">allSpawnsEmpty</a> ()</td></tr>
<tr class="memdesc:ab1fad3d976a75359b9765e9f0fd6446c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all enemy Spawns are empty.  <a href="#ab1fad3d976a75359b9765e9f0fd6446c">More...</a><br /></td></tr>
<tr class="separator:ab1fad3d976a75359b9765e9f0fd6446c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8efb03237fde65063b48cfa6ee8faf2"><td class="memItemLeft" align="right" valign="top">sf::Texture &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ac8efb03237fde65063b48cfa6ee8faf2">getTexture</a> (const int &amp;id=0)</td></tr>
<tr class="memdesc:ac8efb03237fde65063b48cfa6ee8faf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns texture defined by ID.  <a href="#ac8efb03237fde65063b48cfa6ee8faf2">More...</a><br /></td></tr>
<tr class="separator:ac8efb03237fde65063b48cfa6ee8faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2a7a1ea4ba76d2268507da91245167"><td class="memItemLeft" align="right" valign="top"><a id="adc2a7a1ea4ba76d2268507da91245167"></a>
<a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#adc2a7a1ea4ba76d2268507da91245167">getSize</a> () const</td></tr>
<tr class="memdesc:adc2a7a1ea4ba76d2268507da91245167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns level size. <br /></td></tr>
<tr class="separator:adc2a7a1ea4ba76d2268507da91245167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449ad2df25fcd0c7410d0c646c2c36b6"><td class="memItemLeft" align="right" valign="top"><a id="a449ad2df25fcd0c7410d0c646c2c36b6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a449ad2df25fcd0c7410d0c646c2c36b6">getCastleHPpart</a> () const</td></tr>
<tr class="memdesc:a449ad2df25fcd0c7410d0c646c2c36b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns part of Castle HP (current/maximum). <br /></td></tr>
<tr class="separator:a449ad2df25fcd0c7410d0c646c2c36b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c5fe1d9eb162f676ce87fd2816596b"><td class="memItemLeft" align="right" valign="top"><a id="ad5c5fe1d9eb162f676ce87fd2816596b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ad5c5fe1d9eb162f676ce87fd2816596b">getGold</a> () const</td></tr>
<tr class="memdesc:ad5c5fe1d9eb162f676ce87fd2816596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns player's gold number. <br /></td></tr>
<tr class="separator:ad5c5fe1d9eb162f676ce87fd2816596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994309f3018ba3e0b00657dd15e47545"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a994309f3018ba3e0b00657dd15e47545">draw</a> (sf::RenderWindow &amp;window)</td></tr>
<tr class="memdesc:a994309f3018ba3e0b00657dd15e47545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all level objects in the window.  <a href="#a994309f3018ba3e0b00657dd15e47545">More...</a><br /></td></tr>
<tr class="separator:a994309f3018ba3e0b00657dd15e47545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0f2aca1e8f0f4b873986eb1d21c993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a8b0f2aca1e8f0f4b873986eb1d21c993">clickEnemy</a> (const int &amp;x, const int &amp;y) const</td></tr>
<tr class="memdesc:a8b0f2aca1e8f0f4b873986eb1d21c993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if given position (in pixels, in window coordinates) is inside any <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a>'s sprite.  <a href="#a8b0f2aca1e8f0f4b873986eb1d21c993">More...</a><br /></td></tr>
<tr class="separator:a8b0f2aca1e8f0f4b873986eb1d21c993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae678dc7b07444c0762acc023dabd8dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ae678dc7b07444c0762acc023dabd8dc2">clickTile</a> (const int &amp;x, const int &amp;y) const</td></tr>
<tr class="memdesc:ae678dc7b07444c0762acc023dabd8dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if given position (in pixels, in window coordinates) is inside any tile.  <a href="#ae678dc7b07444c0762acc023dabd8dc2">More...</a><br /></td></tr>
<tr class="separator:ae678dc7b07444c0762acc023dabd8dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2567806ec16836d0821a6deaf0a6b33"><td class="memItemLeft" align="right" valign="top"><a id="ad2567806ec16836d0821a6deaf0a6b33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ad2567806ec16836d0821a6deaf0a6b33">getTowerBuildCost</a> () const</td></tr>
<tr class="memdesc:ad2567806ec16836d0821a6deaf0a6b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Tower build cost (for level 0) <br /></td></tr>
<tr class="separator:ad2567806ec16836d0821a6deaf0a6b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6cf1d0ed67fbf539833407e3d47e7a"><td class="memItemLeft" align="right" valign="top"><a id="a8a6cf1d0ed67fbf539833407e3d47e7a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a8a6cf1d0ed67fbf539833407e3d47e7a">getWallBuildCost</a> () const</td></tr>
<tr class="memdesc:a8a6cf1d0ed67fbf539833407e3d47e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Wall build cost. <br /></td></tr>
<tr class="separator:a8a6cf1d0ed67fbf539833407e3d47e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5685eb632b1b696ec2dcaf0a2646841"><td class="memItemLeft" align="right" valign="top"><a id="aa5685eb632b1b696ec2dcaf0a2646841"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aa5685eb632b1b696ec2dcaf0a2646841">getWallRepairCost</a> () const</td></tr>
<tr class="memdesc:aa5685eb632b1b696ec2dcaf0a2646841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Wall repair cost (for 1 HP) <br /></td></tr>
<tr class="separator:aa5685eb632b1b696ec2dcaf0a2646841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e5fcbebae833babb84780b4ce2d7f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a11e5fcbebae833babb84780b4ce2d7f1">getTowerUpgradeCost</a> (const int &amp;curLvl) const</td></tr>
<tr class="memdesc:a11e5fcbebae833babb84780b4ce2d7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Tower upgrade cost (from the given level)  <a href="#a11e5fcbebae833babb84780b4ce2d7f1">More...</a><br /></td></tr>
<tr class="separator:a11e5fcbebae833babb84780b4ce2d7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b4996065893b2043d4cc010f35c829"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a71b4996065893b2043d4cc010f35c829">getCastleUpgradeCost</a> (const int &amp;curLvl) const</td></tr>
<tr class="memdesc:a71b4996065893b2043d4cc010f35c829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Castle upgrade cost (from the given level)  <a href="#a71b4996065893b2043d4cc010f35c829">More...</a><br /></td></tr>
<tr class="separator:a71b4996065893b2043d4cc010f35c829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4421bac35a2247aed901d06682568ef0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_t_stats.html">TStats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a4421bac35a2247aed901d06682568ef0">getNextTowerLevel</a> (const int &amp;curLvl) const</td></tr>
<tr class="memdesc:a4421bac35a2247aed901d06682568ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the stats of the next Tower level.  <a href="#a4421bac35a2247aed901d06682568ef0">More...</a><br /></td></tr>
<tr class="separator:a4421bac35a2247aed901d06682568ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb50eb43dd690348e71bebba000f7ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_c_stats.html">CStats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#afdb50eb43dd690348e71bebba000f7ff">getNextCastleLevel</a> (const int &amp;curLvl) const</td></tr>
<tr class="memdesc:afdb50eb43dd690348e71bebba000f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the stats of the next Castle level.  <a href="#afdb50eb43dd690348e71bebba000f7ff">More...</a><br /></td></tr>
<tr class="separator:afdb50eb43dd690348e71bebba000f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac854fa5b9c24d5c1464370d56de964d8"><td class="memItemLeft" align="right" valign="top"><a id="ac854fa5b9c24d5c1464370d56de964d8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#ac854fa5b9c24d5c1464370d56de964d8">getInfoHP</a> () const</td></tr>
<tr class="memdesc:ac854fa5b9c24d5c1464370d56de964d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information string about Castle HP. <br /></td></tr>
<tr class="separator:ac854fa5b9c24d5c1464370d56de964d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacafdfe4dc8af2bf97d3865314ea90e7"><td class="memItemLeft" align="right" valign="top"><a id="aacafdfe4dc8af2bf97d3865314ea90e7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#aacafdfe4dc8af2bf97d3865314ea90e7">getGamestate</a> () const</td></tr>
<tr class="memdesc:aacafdfe4dc8af2bf97d3865314ea90e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current game state. <br /></td></tr>
<tr class="separator:aacafdfe4dc8af2bf97d3865314ea90e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main game class. </p>
<p>Contains all map data, configs, textures, other info about game level. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a86cf3beee1987babb82fbf81e9b2cc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cf3beee1987babb82fbf81e9b2cc0c">&#9670;&nbsp;</a></span>Level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">P4v25_SFML::Level::Level </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fconfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fsave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> constructor. </p>
<p>Constructs level from three files. Loads all map data, tileset, textures, configs and save. If loaded, checks all critical situations, launches pathfinder and other functions. If everthing is right, level is ready for the game.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmap</td><td>The path to map file (Tiled map editor, .tmx) </td></tr>
    <tr><td class="paramname">fconfig</td><td>The path to config file (Text file, .cfg) </td></tr>
    <tr><td class="paramname">fconfig</td><td>The path to save file (Text file, .sav) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd7b4f57e00b7162478edb6043aed16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b4f57e00b7162478edb6043aed16e">&#9670;&nbsp;</a></span>addEnemy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void P4v25_SFML::Level::addEnemy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> *&#160;</td>
          <td class="paramname"><em>ne</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds enemy to the level. </p>
<p>Doesn't copy <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a>, just inserts its pointer to the list. Used to transfer <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> pointers from Spawns to Map. </p>

</div>
</div>
<a id="ab1fad3d976a75359b9765e9f0fd6446c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fad3d976a75359b9765e9f0fd6446c">&#9670;&nbsp;</a></span>allSpawnsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool P4v25_SFML::Level::allSpawnsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all enemy Spawns are empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true If all enemy Spawns are empty. </dd>
<dd>
false If there are some enemies left in any of spawns. </dd></dl>

</div>
</div>
<a id="a159a1ce01a1473a5545e186da9e3d425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159a1ce01a1473a5545e186da9e3d425">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds something at the position. </p>
<p>Checks if position is available and if selected tile is empty from buildings (plains) and enemies. Checks if gold is enough for the selected building type. Checks if building doesn't completely block path from spawns to the Castle for light infantry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Position for the building </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="class_p4v25___s_f_m_l_1_1_building.html">Building</a> type (11 for Wall, 12 for Tower). </td></tr>
    <tr><td class="paramname">name</td><td><a class="el" href="class_p4v25___s_f_m_l_1_1_building.html">Building</a> name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If everything is good. </dd>
<dd>
0 If position doesn't exist (doesn't fit in level size, or &lt;0). </dd>
<dd>
-1 If tile type is not Plains. </dd>
<dd>
-2 If gold is not enough. </dd>
<dd>
-3 If the building blocks path for light infantry. </dd>
<dd>
-4 If enemies are at the building position </dd></dl>

</div>
</div>
<a id="abb994bef73c7dead6fd1d92c652b47a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb994bef73c7dead6fd1d92c652b47a2">&#9670;&nbsp;</a></span>calcTimeQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double P4v25_SFML::Level::calcTimeQ </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>maxTQ</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates time quant for this level, saves and returns it. </p>
<p>Time quant is minimum time until the next change of the level:</p><ul>
<li>Releasing enemies from any Spawn</li>
<li>Full reload of the Tower.</li>
<li>Sending gold from the Castle.</li>
<li>Reaching the next tile by any enemy. If maximum time quant is provided (usually frame period), timeQ is limited by maxTQ.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTQ</td><td>Maximum time quant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time quant </dd></dl>

</div>
</div>
<a id="a8f189f8b41a9ae0440b77a42e489d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f189f8b41a9ae0440b77a42e489d279">&#9670;&nbsp;</a></span>checkPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool P4v25_SFML::Level::checkPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given position is within the level. </p>
<dl class="section return"><dt>Returns</dt><dd>true If position is within the level. </dd>
<dd>
false If position is outside the level. </dd></dl>

</div>
</div>
<a id="a8b0f2aca1e8f0f4b873986eb1d21c993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0f2aca1e8f0f4b873986eb1d21c993">&#9670;&nbsp;</a></span>clickEnemy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a> * P4v25_SFML::Level::clickEnemy </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if given position (in pixels, in window coordinates) is inside any <a class="el" href="class_p4v25___s_f_m_l_1_1_enemy.html">Enemy</a>'s sprite. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> top-left coordinates must be (0,0)! Otherwise doesn't work correctly. If position is within several sprites, chooses the last of them in the list. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to selected enemy </dd>
<dd>
nullptr if there's no enemies at the given position </dd></dl>

</div>
</div>
<a id="ae678dc7b07444c0762acc023dabd8dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae678dc7b07444c0762acc023dabd8dc2">&#9670;&nbsp;</a></span>clickTile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> P4v25_SFML::Level::clickTile </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if given position (in pixels, in window coordinates) is inside any tile. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> top-left coordinates must be (0,0)! Otherwise doesn't work correctly. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the selected tile </dd>
<dd>
(-1, -1) if the position is outside the level. </dd></dl>

</div>
</div>
<a id="a431eee96536e68270fe1ce7d06d05570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431eee96536e68270fe1ce7d06d05570">&#9670;&nbsp;</a></span>destroyBuilding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void P4v25_SFML::Level::destroyBuilding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys building at the tile. </p>
<p>Destroys building at the selected tile, changes its type to Plains, launches pathfind. May change game state if Castle is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> of the building</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception("Level:destroyBuilding:illegal_type")</td><td>If there is no building or if it can't be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a994309f3018ba3e0b00657dd15e47545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994309f3018ba3e0b00657dd15e47545">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void P4v25_SFML::Level::draw </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all level objects in the window. </p>
<p>Drawing order:</p><ol type="1">
<li>Tiles, buildings, HPbars.</li>
<li>Enemies, HPbars.</li>
<li>Tower ranges.</li>
<li><a class="el" href="class_p4v25___s_f_m_l_1_1_hero.html">Hero</a> aura circles. </li>
</ol>

</div>
</div>
<a id="a71b4996065893b2043d4cc010f35c829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b4996065893b2043d4cc010f35c829">&#9670;&nbsp;</a></span>getCastleUpgradeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::getCastleUpgradeCost </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>curLvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Castle upgrade cost (from the given level) </p>
<p>Levels are measured from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curLvl</td><td>Current Castle level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cost of the upgrade to the next level. </dd>
<dd>
-1 if maximum level is reached already. </dd></dl>

</div>
</div>
<a id="a2a0cb5464849681d105baf99ff39e97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0cb5464849681d105baf99ff39e97e">&#9670;&nbsp;</a></span>getCS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_c_stats.html">CStats</a> &amp; P4v25_SFML::Level::getCS </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Castle stats for the selected level (from 0). </p>
<p>Checks if the level exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl</td><td><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception("Level:getCS:illegal_level")</td><td>If the selected level doesn't exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant Link to the stats. </dd></dl>

</div>
</div>
<a id="afdb50eb43dd690348e71bebba000f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb50eb43dd690348e71bebba000f7ff">&#9670;&nbsp;</a></span>getNextCastleLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_c_stats.html">CStats</a> * P4v25_SFML::Level::getNextCastleLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>curLvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the stats of the next Castle level. </p>
<p>Levels are measured from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curLvl</td><td>Current Castle level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next level stats. </dd>
<dd>
nullptr if maximum level is reached already. </dd></dl>

</div>
</div>
<a id="a4421bac35a2247aed901d06682568ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4421bac35a2247aed901d06682568ef0">&#9670;&nbsp;</a></span>getNextTowerLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_t_stats.html">TStats</a> * P4v25_SFML::Level::getNextTowerLevel </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>curLvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the stats of the next Tower level. </p>
<p>Levels are measured from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curLvl</td><td>Current Tower level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next level stats. </dd>
<dd>
nullptr if maximum level is reached already. </dd></dl>

</div>
</div>
<a id="ac8efb03237fde65063b48cfa6ee8faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8efb03237fde65063b48cfa6ee8faf2">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::Texture&amp; P4v25_SFML::Level::getTexture </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns texture defined by ID. </p>
<p>Texture IDs are defined in <a class="el" href="_common_8h_source.html">Common.h</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If there's no texture with given ID in current tileset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Link to the texture. </dd></dl>

</div>
</div>
<a id="a11e5fcbebae833babb84780b4ce2d7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e5fcbebae833babb84780b4ce2d7f1">&#9670;&nbsp;</a></span>getTowerUpgradeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::getTowerUpgradeCost </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>curLvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Tower upgrade cost (from the given level) </p>
<p>Levels are measured from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curLvl</td><td>Current Tower level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cost of the upgrade to the next level. </dd>
<dd>
-1 if maximum level is reached already. </dd></dl>

</div>
</div>
<a id="ae6c76fa6c6acfc97caa1e19cdbaf656d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c76fa6c6acfc97caa1e19cdbaf656d">&#9670;&nbsp;</a></span>getTS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_t_stats.html">TStats</a> &amp; P4v25_SFML::Level::getTS </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Tower stats for the selected level (from 0). </p>
<p>Checks if the level exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl</td><td><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html" title="Main game class. ">Level</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception("Level:getTS:illegal_level")</td><td>If the selected level doesn't exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant Link to the stats. </dd></dl>

</div>
</div>
<a id="a239ef78814c80da434250a4b69c31502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239ef78814c80da434250a4b69c31502">&#9670;&nbsp;</a></span>killEnemy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">Level::iterator</a> P4v25_SFML::Level::killEnemy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">Level::iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kills the enemy pointed by the iterator. </p>
<p>Kills enemy pointed by the iterator. If hero was killed, launches auraCheck() for each enemy. May change gamestate if no enemies are left &amp; all Spawns are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to the enemy being killed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the next enemy in the list. </dd></dl>

</div>
</div>
<a id="a0e9a32ce9284ec35334dcf20b946f1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9a32ce9284ec35334dcf20b946f1f2">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p4v25___s_f_m_l_1_1_tile.html">Tile</a> &amp; P4v25_SFML::Level::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns link to (x, y) tile. SAFE: Checks if the tile exists. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception("Level:operator[]:illegal_position")</td><td>if the tile doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53cde934cd1b5500fc936fe7efce6b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cde934cd1b5500fc936fe7efce6b6d">&#9670;&nbsp;</a></span>pathfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool P4v25_SFML::Level::pathfind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pathfind algorithm. </p>
<p>Finds paths from all tiles to the castle, uses BFS graph algorithm. For each map tile finds the next tile and distance to the castle for all main enemy types. If cannot find path from the tile to the castle, distance = -1, and next tile is current tile.</p>
<p>Checks if there are path for light infantry from Spawns to Castle.</p>
<dl class="section return"><dt>Returns</dt><dd>1 Castle is available from all Spawns </dd>
<dd>
0 Can't find path from any Spawn. </dd></dl>

</div>
</div>
<a id="a2030a6c62aa5eb91bec3057de7fdd607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2030a6c62aa5eb91bec3057de7fdd607">&#9670;&nbsp;</a></span>pf_visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void P4v25_SFML::Level::pf_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>curP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>prevP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pathfind visit function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curP</td><td>Current tile position </td></tr>
    <tr><td class="paramname">prevP</td><td>Previous (from the castle) tile position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2917dd109c1cab686d8abe811683a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2917dd109c1cab686d8abe811683a5">&#9670;&nbsp;</a></span>removeEnemy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">Level::iterator</a> P4v25_SFML::Level::removeEnemy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4v25___s_f_m_l_1_1_level.html#a9989021a9567747ccec7cb8dc5e51002">Level::iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the enemy pointed by the iterator from the list. </p>
<p>Deletes info about enemy and erases its pointer from the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator to the enemy being removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the next enemy in the list. </dd></dl>

</div>
</div>
<a id="ae368bfb4ca44e317f41b66c3df2824a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae368bfb4ca44e317f41b66c3df2824a7">&#9670;&nbsp;</a></span>repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::repair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>healHP</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repairs selected wall. </p>
<p>Repairs wall at the position. Too high heal values is not a problem: wall will be healed to its maximum HP. If heal value &lt;= 0 - same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Position of the wall</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If everything is good. </dd>
<dd>
0 If position doesn't exist (doesn't fit in level size, or &lt;0). </dd>
<dd>
-1 If wall doesn't exist at this position. </dd>
<dd>
-2 If gold is not enough. </dd></dl>

</div>
</div>
<a id="aeb5520253f0452c7e09b2bebeda1a209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5520253f0452c7e09b2bebeda1a209">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void P4v25_SFML::Level::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fsave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves level. </p>
<p>Saves game info to text file, overwriting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsave</td><td>Save file path (.sav) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d90637e4e9f416c9027b5adb29dc546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d90637e4e9f416c9027b5adb29dc546">&#9670;&nbsp;</a></span>turn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::turn </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>maxTQ</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main turn function. </p>
<p>Makes one turn until the next change of the level:</p><ul>
<li>Releasing enemies from any Spawn</li>
<li>Full reload of the Tower.</li>
<li>Sending gold from the Castle.</li>
<li>Reaching the next tile by any enemy. If maximum time quant is provided (usually frame period), time quant is limited by maxTQ.</li>
</ul>
<p>Turn order:</p><ol type="1">
<li>Castle regenerates.</li>
<li>Castle sends gold (if ready).</li>
<li>Spawn releases enemies (if ready).</li>
<li>Enemies regenerate.</li>
<li>Enemies move or attack their targets.</li>
<li>Towers shoot at enemies (if ready).</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTQ</td><td>Maximum time quant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New game state. </dd></dl>

</div>
</div>
<a id="a5f2242763319c5896c78766f90ca7ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2242763319c5896c78766f90ca7ad8">&#9670;&nbsp;</a></span>turnUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::turnUntil </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>extTQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes several turns until external time quant. </p>
<p>Makes several turns until the sum of their time quants reaches external time quant OR until gamestate changes to WIN or LOSE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extTQ</td><td>External time quant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New game state. </dd></dl>

</div>
</div>
<a id="a69e2923c6d401195bc6c50cb730f86b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e2923c6d401195bc6c50cb730f86b4">&#9670;&nbsp;</a></span>upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4v25_SFML::Level::upgrade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4v25___s_f_m_l_1_1_pos.html">Pos</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upgrades the building at the position. </p>
<p>Checks if position exists. Checks if building exists and can be upgraded by player. Checks if gold is enough. Checks if maximum level is not reached yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Position of the building</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If everything is good. </dd>
<dd>
0 If position doesn't exist (doesn't fit in level size, or &lt;0). </dd>
<dd>
-1 If building doesn't exist or can't be upgraded by player. </dd>
<dd>
-2 If gold is not enough. </dd>
<dd>
-3 If maximum level is already reached. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>P4v25_Library_SFML/<a class="el" href="_level_8h_source.html">Level.h</a></li>
<li>P4v25_Library_SFML/Level.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
